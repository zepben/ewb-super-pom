name: Build CI Container

on:
  repository_dispatch:
    types: [build-container]
  workflow_dispatch:
    inputs:
      commit:
        description: 'Initial commit to layer the resulting image'
        required: true
        type: string
 
jobs:
  parse-inputs:
    runs-on: ubuntu-latest
    outputs:
      commits: ${{ steps.check.outputs.commits }}
      action_build_container: ${{ steps.check.outputs.action_build_container }}
      base_commit: ${{ steps.check.outputs.base_commit }}
      pipeline_java_commit: ${{ steps.check.outputs.pipeline_java_commit }}
      pipeline_java_version: ${{ steps.check.outputs.pipeline_java_version }}
    steps:
      - uses: actions/checkout@v4

      - name: Check inputs
        id: check
        run: |
          # Check whether the commit was provided
          if [ "z${{ inputs.commit }}" != "z" ]; then
            # We're on some commit, so rebuild the whole thing
            echo "commits=$(git rev-list --ancestry-path ${{ inputs.commit }}~1..HEAD)" >> $GITHUB_OUTPUT
            echo "action_build_container=zepben/pipeline-java" >> $GITHUB_OUTPUT
            echo "base_commmit=${{ inputs.commit }}" >> $GITHUB_OUTPUT
          else
            # We're on HEAD, so update the existing image
            echo "commits=HEAD" >> $GITHUB_OUTPUT
            echo "action_build_container=zepben/pipeline-java-ewb" >> $GITHUB_OUTPUT
            echo "base_commmit=$(skopeo inspect zepben/pipeline-java-ewb | jq .Labels.base_commit)" >> $GITHUB_OUTPUT
          fi 

          # TODO: fetch both in 1 go?
          echo "pipeline_java_commit=$(skopeo inspect zepben/pipeline-java | jq .Labels.commit)" >> $GITHUB_OUTPUT
          echo "pipeline_java_version=$(skopeo inspect zepben/pipeline-java | jq .Labels.version)" >> $GITHUB_OUTPUT

  build-repository:
    runs-on: ubuntu-latest
    needs: [parse-inputs]
    container: ${{ needs.parse-inputs.outputs.action_build_container }} 
    env:
      ZEPBEN_GPG_KEY: ${{ secrets.ZEPBEN_GPG_KEY }}
      MAVEN_SETTINGS: ${{ secrets.MAVEN_SETTINGS }}
      OSSRH_USERNAME: ${{ secrets.OSSRH_USERNAME }}
      OSSRH_PASSWORD: ${{ secrets.OSSRH_PASSWORD }}
      GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      GPG_KEY_PASSWORD: ${{ secrets.GPG_KEY_PASSWORD }}
      DOCKER_HUB_ACCESS_TOKEN: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      DOCKER_HUB_USER: ${{ secrets.DOCKER_HUB_USER }}
    steps:
      - uses: actions/checkout@v4

      - name: Build repository
        id: build
        run: |
          for commit in ${{ needs.parse-inputs.outputs.commits }}; do
            git checkout $commit
            ./maven-build.sh 
          done 
        shell: bash

      - name: Store repository for wrapping in container  
        uses: action/upload-artefact@v4
        id: upload
        if: steps.build.outcome == 'success'
        with:
          name: /root/local_repo
          path: /root/local_repo 
          if-no-files-found: error
        continue-on-error: false

  build-container:
    runs-on: ubuntu-latest
    needs: [parse-inputs, build-repository]
    outputs:
      push: ${{ steps.labels.outputs.push }}
    env:
      DOCKER_HUB_ACCESS_TOKEN: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      DOCKER_HUB_USER: ${{ secrets.DOCKER_HUB_USER }}
      LOCAL_REPO: local_repo
      BASE_IMAGE: zepben/pipeline-java
    steps:

      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Github Container Registry
        uses: docker/login-action@v3
        with:
          username: $DOCKER_HUB_USER
          password: $DOCKER_HUB_ACCESS_TOKEN

      - name: Download repository
        uses: actions/download-artifact@v4
        with:
          name: /root/local_repo
          path: $LOCAL_REPO
          continue-on-error: false


      - name: Figure out tags and labels
        id: labels
        run: |
          # Handle the base image if provided
          if [ "z${{ github.event.client_payload.base_image }}" != "z" ]; then
            # Some label was given via remote call
            echo "BASE_IMAGE=${{ github.event.client_payload.base_image }}" >> $GITHUB_ENV
            
            echo ${{ github.event.client_payload.base_image }} | grep ":test"
            if [ $? == 0 ]; then
               echo "push=no" >> $GITHUB_OUTPUT
            fi
          fi

          REF_NAME=$GITHUB_REF_NAME
          # TODO: Make sure labels is an array
          SHORT_REF=$(git rev-parse --short HEAD)
          if [[ $REF_NAME == "main" ]]; then
            tags=(latest ${SHORT_REF}")
          else
            tags=(${REF_NAME} ${REF_NAME}-${SHORT_REF})
          fi

          # tags=$(printf "-t docker.io/zepben/pipeline-java-ewb:%s " "${tags[@]}")
          cat Dockerfile.in | envsubst > Dockerfile

      # Priority sorting determines the tag used in the OCI label
      # The current order preferences the version, then commit, then any special tags
      # We always push a commit based tag
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: zepben/pipeline-java-ewb
          labels: |
            base_commit=${{ needs.parse-inputs.outputs.base_commit }}
            end_commit=$GITHUB_REF
            pipeline_java_commit=${{ needs.parse-inputs.outputs.pipeline_java_commit }}
            pipeline_java_version=${{ needs.parse-inputs.outputs.pipeline_java_version }}
            org.opencontainers.image.vendor=Zepben
          tags: |
            type=raw,value=sha-${{ steps.sha.outputs.short_ref }},enable=${{ true }},priority=200
            type=raw,value=sha-${{ steps.sha.outputs.long_ref }},enable=${{ true }},priority=220
            type=raw,value=${{ github.event.client_payload.version }},enable=${{ github.event.client_payload.version != '' }},priority=900
            type=raw,value=latest,enable=${{ inputs.latest_tag }},priority=100


      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: ${{ inputs.push_image }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          file: ${{ inputs.dockerfile }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: ${{ inputs.build-args }}
          secret-files: |
            npm=/home/runner/.npmrc
            maven=/home/runner/.m2/settings.xml
            nuget=/home/runner/.nuget/NuGet/NuGet.Config


